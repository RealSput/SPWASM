let array = (l) {
    return [null] * l;
}

type @stack_vm
impl @stack_vm {
    create: () {
        return @stack_vm::{stack: [], pc: 0, table: [], lc: 0}
    },
    set_memory: (self, pages) {
        self.memory = array(pages * 1024);
    },
    execute: (self, instruction) {
        match(instruction.opcode) {
            =="i32.const": () {
                self.stack.push(instruction.args[0]);
                }(),
            =="i32.add": () {
                let b = self.stack.pop();
                let a = self.stack.pop();
                self.stack.push(a + b);
                }(),
            =="i32.sub": () {
                let d = self.stack.pop();
                let c = self.stack.pop();
                self.stack.push(c - d);
                }(),
            =="table": () {
                self.table = array(instruction.args[0])
                }(),
            =="elem": () {
                let offset = self.stack.pop();
                for i in instruction.args {
                    let func_name = instruction.args[i + 1];
                    let func = self.functions[func_name];
                    self.table[offset + i] = func;
                }
                }(),
            =="call_indirect": () {
                if (self.stack.length < 1) {
                    throw "Stack underflow";
                }
                let func_index = self.stack.pop();
                if (func_index.type != @number) {
                    throw "Invalid function index";
                }
                let func = self.functions[func_index];
                if (func) {
                    func();
                } else {
                    throw "Function at index {} not found".fmt(func_index);
                }
                }(),
            =="i32.store": () {
                let value_i32s = instruction.args[0];
                let offset_i32s = instruction.args[1];
                self.memory[offset_i32s] = value_i32s;
                }(),
            =="i32.load": () {
                let offset_i32l = instruction.args[0];
                self.stack.push(self.memory[offset_i32l]);
                }(),
            =="local.get": () {
                let res = self.params[instruction.args[0]];
                self.stack.push(res);
                }(),
            else: () {
                throw "Unknown opcode: {}".fmt(instruction.opcode);
}()
        }
        self.pc++;
    },

    run: (self, code, let args = []) {
        let self.params = [];
        while (self.pc < code.length) {
            let instruction = code[self.pc];
            self.params = args
            self.execute(instruction);
        }
        return self.stack;
    }
}

let vm = @stack_vm::create()
vm.set_memory(1);
let d = vm.run([
  { opcode: 'local.get', args: [ 'x' ] },
  { opcode: 'local.get', args: [ 'y' ] },
  { opcode: 'i32.add', args: [] }
], {x: 10, y: 10});
$.print(d);
